---
title: "Visualizing Ambiguity: A Grammar of Graphics Approach to Resolving Numerical Ties in Parallel Coordinate Plots"
author: "Denise Bradford"
date: "Updated November 2025"
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    documentclass: article
    geometry: margin=1in
    fontsize: 11pt
    include-in-header:
      text: |
        \usepackage{soul}
        \usepackage[dvipsnames]{xcolor} % colors
        \newcommand{\db}[1]{{\textcolor{Green}{#1}}}
        \newcommand{\svp}[1]{{\textcolor{RedOrange}{#1}}}
        \newcommand{\hh}[1]{{\textcolor{blue}{#1}}}
    html:
      css: edits.css
bibliography: references_summary.bib
bibliographystyle: apa
filters:
   - latex-environment
commands: [db,svp,hh]
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, 
  message = FALSE, 
  warning = FALSE,
  fig.width = 8,
  fig.height = 5,
  dpi = 300
)

# Load required packages
library(GGally)
library(palmerpenguins)
library(tidyverse)
library(gridExtra)
library(ggpcp)
library(datasets)
library(knitr)
library(kableExtra)

source(here::here("Numerical_ties_pcp.R"))


# Set theme
theme_set(theme_bw(base_size = 12))

# Color scales for iris
iris_scale_color <- function(...) {
  scale_color_manual(
    "Species", 
    values = c("setosa" = "#540D6E", 
               "versicolor" = "#219B9D", 
               "virginica" = "#FF8000"), 
    ...
  )
}

iris_scale_fill <- function(...) {
  scale_fill_manual(
    "Species", 
    values = c("setosa" = "#540D6E", 
               "versicolor" = "#219B9D", 
               "virginica" = "#FF8000"), 
    ...
  )
}

# Clean iris data
iris_clean <- iris %>% na.omit()

img_van_der <- here::here("comprehensive_exam_files", "images", "Van_der_corput_distribution.jpeg")
img_daisy <- here::here("comprehensive_exam_files", "images", "daisy.jpeg")
img_vdc <- here::here("comprehensive_exam_files", "images","vdc_sequence.jpeg")
img_golden_angle <- here::here("comprehensive_exam_files", "images","Phyllotaxis_golden_angle.jpeg")
img_golden_ratio <- here::here("comprehensive_exam_files", "images","TheGoldenRationGraphic.jpeg")

```

# Introduction

This proposal outlines a systematic approach to visually distinguish tied numerical values in multidimensional datasets by employing parallel coordinate plots (PCPs). 
Parallel coordinates, first popularized by Alfred Inselberg, are a powerful technique for investigating patterns across multiple attributes simultaneously [@inselberg2009]. 
However, when datasets contain exact numerical ties, the resulting overlapping lines in PCPs can obscure critical distinctions. 

To address this, we propose three deterministic methods for introducing controlled spacing to tied values: **Halton jitter** (quasi-random sequences), **Sunflower jitter** (biomimetic distribution), and **Intelligent jitter** (golden ratio application). 
These methods will be integrated into the `ggpcp` package in R, ensuring a streamlined workflow for users seeking enhanced clarity in their parallel coordinate visualizations.

Importantly, our approach complements recent work on generalized parallel coordinate plots (GPCPs), an extension of PCPs that supports categorical variables [@vanderplas2023]. 
The `ggpcp` package for R implements these GPCPs using a grammar of graphics framework, which seamlessly incorporates both continuous and categorical variables in a single parallel coordinate plot. 
One of the key contributions of that work is a robust tie-breaking mechanism for categorical variables, implemented through the `pcp_arrange()` function with methods including "from-left" and "from-right" hierarchical sorting. 
This ensures that individual observations can be traced across multiple dimensions, even when categories induce identical or "tied" values. 

By adding multiple numerical tie-breaking techniques for continuous data—including our three deterministic approaches—we further refine GPCPs' capacity to handle the visualization of real-world datasets exhibiting many types of ties.

# Background and Motivation

## Parallel Coordinate Plots

Parallel coordinate plots assign each dimension of an $n$-dimensional dataset to a vertical axis arranged in parallel [@wegman1990]. 
Each observation is drawn as a polyline connecting its values on these axes, providing a visual representation that can illuminate underlying data structures.

## Numerical Ties and Visual Overlap

When multiple observations share the same value in a given dimension, their polylines perfectly overlap, creating "visual collisions." 
This masks information about distribution, density, or potential outliers. 
The treatment of ties is an aspect not generally addressed in the original parallel coordinate plots of Inselberg [-@inselberg1985] and Wegman [-@wegman1990]. 
However, the `ggpcp` implementation has demonstrated that careful tie-handling is essential for both continuous and categorical variables.

Introducing a small offset ("jitter") to these tied values can mitigate overlap without distorting the overall relationships in the data [@peng2004]. 
In the context of generalized parallel coordinate plots, the `ggpcp` package separates data management from visual rendering into three distinct components: variable selection and reshaping, scaling of axes, and treatment of ties in categorical axes [@vanderplas2023].

```{r ggpcp-workflow, fig.cap="ggpcp data wrangling workflow", out.width="70%"}
p1
```

## Existing Solutions for Categorical Ties in ggpcp

The `ggpcp` package currently addresses categorical ties through sophisticated tie-breaking algorithms. 
The package implements hierarchical sorting through the `pcp_arrange(data, method, space)` function, with two primary methods: "from-left" and "from-right", meaning that tie breaks are determined hierarchically by variables' values from the specified direction. 
The parameter `space` specifies the amount of the y-axis to use for spacing between levels of categorical variables, with a default of 5% of the axis used for spacing.

This hierarchical sorting approach serves as "external cognition"—the additional computational processing reduces the cognitive load required to untangle overlapping lines in the parallel coordinate plot. 
The categorical tie-breaking creates equispaced tie-breaking that reduces line crossings and allows users to follow individual observations from left to right through the plot even for categorical variables.

## The Gap: Numerical Ties Remain Unsolved

While categorical ties have been elegantly solved in `ggpcp`, numerical ties present distinct challenges:

- **Continuous nature**: Unlike discrete categories, numerical values exist on a continuum
- **Density information**: The number of tied observations carries important statistical meaning
- **Perceptual requirements**: Displacement must be small enough to maintain value integrity yet large enough for visual separation
- **Reproducibility**: Scientific visualization requires deterministic, reproducible results

Standard random jittering, while commonly used, suffers from:

1. **Non-reproducibility**: Different runs produce different visualizations
2. **Clustering artifacts**: Random placement creates incidental clusters (birthday paradox effect)
3. **Uneven distribution**: Large gaps and dense regions appear by chance
4. **Misleading density**: Visual patterns don't faithfully represent data frequency

# Design Requirements for Numerical Tie Resolution

Any solution to numerical tie resolution must satisfy four core principles:

## Determinism

**Requirement**: Identical input must produce identical output.

**Rationale**: Essential for scientific reproducibility [@peng2011]. 
Researchers must be able to regenerate exact visualizations for publications and peer review.

**Implication**: Rules out standard random jitter approaches.

## Uniformity

**Requirement**: Even distribution within displacement interval with minimal clustering.

**Rationale**: 

- Faithful representation of density
- Minimize artificial patterns
- Ensure visual density corresponds to data frequency

**Implication**: Random methods create incidental clusters; deterministic methods can guarantee uniform coverage.

## Perceptual Validity

**Requirement**: Displacement must balance two competing needs:

- Small enough to maintain value integrity
- Large enough for visual separation

**Rationale**: Users must be able to trust that displaced values remain close to true values while still being visually distinguishable [@ware2012].

**Implication**: Requires careful parameter selection ($\epsilon$) and potentially adaptive methods.

## Scalability

**Requirement**: Handle 2 to 10,000+ observations per tie group efficiently.

**Rationale**: 

- Real-world datasets vary enormously in size
- Interactive exploration requires real-time performance
- Computational efficiency enables integration into standard workflows

**Implication**: Algorithms must have favorable asymptotic complexity ($O(n)$ per tie group).

# Mathematical Framework

For each tied value $v$ with $n_{\text{ties}}$ observations, we distribute points within a displacement interval:

$$\left[v - \frac{\epsilon}{2}, v + \frac{\epsilon}{2}\right]$$

where $\epsilon$ is the maximum displacement magnitude, typically 0.05–0.10 of the axis range.

## Optimization Goals

1. **Maximize minimum inter-point distance**: Prevent visual collision
2. **Minimize visual artifacts**: Avoid clustering and false patterns
3. **Maintain deterministic reproducibility**: Enable verification
4. **Achieve uniform coverage**: Faithfully represent density

# Three Deterministic Jittering Methods

We propose three methods, each with distinct theoretical foundations and characteristics:

| Method | Theoretical Basis | Dimension | Scaling | Best For |
|--------|------------------|-----------|---------|----------|
| Halton | Quasi-random sequences [@halton1960] | Pure 1D | Constant | Uniform distributions |
| Sunflower | Phyllotaxis [@vogel1979] | 2D → 1D | Sublinear ($\sqrt{n}$) | Aesthetic + performance |
| Intelligent | Golden ratio direct application | Hybrid 1D | Linear | Research comparison |

## Method 1: Sunflower Jitter (Biomimetic Approach)

```{r sunflower-demo, fig.cap="Sunflower jittering resolves ties with biomimetic distribution", fig.width=10, fig.height=5}
# Demonstration of sunflower jitter

p3 +
  iris_scale_color() +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  labs(title = "Sunflower Jitter: Clear Density Visualization",
       x = NULL, y = "Value")

```

### Biological Inspiration

Sunflower seeds arrange themselves following nature's optimization solution for packing efficiency [@vogel1979]. This pattern appears throughout nature in:

```{r natural-demo, fig.cap="Natural Examples of the Nature's Optimaization", out.width="48%"}
knitr::include_graphics(img_daisy)
```


- Sunflower seed heads
- Pine cone spirals
- Romanesco broccoli
- Succulent leaf arrangements
- Daisy florets

The mathematical principle: **The Golden Angle** = $137.5^\circ = 360^\circ \times (2 - \phi)$

where $\phi = \frac{1+\sqrt{5}}{2} \approx 1.618$ is the golden ratio.

### Why This Angle Works

The golden angle is the "most irrational" number in the continued fraction sense:

$$\phi = 1 + \frac{1}{1 + \frac{1}{1 + \frac{1}{1 + \cdots}}}$$

This property ensures:

- **No alignment**: Seeds never align along the same radius, even after hundreds of iterations
- **Optimal packing**: Maximum density with minimum gaps
- **Self-similar structure**: Pattern looks similar at all scales
- **Progressive optimization**: Refined over millions of years

### Mathematical Formulation

For observation $j$ in a tie group of size $n_{\text{ties}}$:

$$\text{angle}_j = (j-1) \times 137.508^\circ$$

$$\text{radius}_j = \epsilon \times \sqrt{\frac{j-1}{n_{\text{ties}}}}$$

$$\text{displacement}_j = \text{radius}_j \times \cos(\text{angle}_j)$$

### Key Features

**Square Root Scaling**: Maintains constant density as radius increases.

In a 2D disk:
- Circumference at radius $r$: $2\pi r$
- Number of points at radius $r_j$: proportional to $j$
- For constant density: $r \propto \sqrt{j}$ balances linear growth in points with radial expansion

**Cosine Projection**: Maps 2D polar coordinates to 1D linear displacement while preserving distribution properties.

**Spiral Structure**: The characteristic spiral pattern is preserved even in 1D projection, creating aesthetically pleasing distributions.

### Theoretical Properties

- **Near-optimal minimum separation** [@vogel1979]
- **Low-discrepancy** in 2D space
- **Aesthetically consistent** across all scales
- **Progressively validated** optimization
- **Deterministic** and fully reproducible

### Algorithm Pseudocode

```
function sunflower_jitter(tied_values, epsilon):
    n = length(tied_values)
    golden_angle = 137.508 * (pi / 180)
    
    displacements = empty_array(n)
    
    for j from 1 to n:
        angle = (j - 1) * golden_angle
        radius = epsilon * sqrt((j - 1) / n)
        displacements[j] = radius * cos(angle)
    
    return tied_values + displacements
```


### Advantages

```{r golden-angle, fig.cap="Phyllotaxis of the Golden Angle", out.width="48%"}
knitr::include_graphics(img_golden_angle)
```

1. **Biomimetic optimization**: Leverages millions of years of natural selection
2. **Aesthetic appeal**: Creates visually pleasing, organic-looking patterns
3. **Balanced distribution**: Neither too uniform (mechanical) nor too random (chaotic)
4. **Proven effectiveness**: Successfully used in nature for optimal packing

### Applications Beyond PCPs

The Sunflower algorithm has proven useful in:

- Point cloud sampling: Uses the Fibonacci angle ($137.5^\circ$) and square-root radial spacing ($r = a\sqrt{\varphi}$) to generate uniformly distributed points on discs or spheres.
- Sphere packing: Places circles or spheres at Sunflower positions to achieve near-optimal packing density in circular domains.
- Texture synthesis: Creates organic, non-repetitive patterns for procedural textures.
- Computer graphics rendering: Provides stratified sample points for stochastic rendering techniques (ray tracing, depth-of-field).
- Quasi-Monte Carlo methods

## Method 2: Halton Jitter (Quasi-Random Sequences)

```{r halton-demo, fig.cap="Halton jittering provides uniform low-discrepancy distribution", fig.width=10, fig.height=5}
# Demonstration of Halton jitter

p2 +
  iris_scale_color() +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  labs(title = "Halton Jitter: Uniform Distribution, No Clustering",
       x = NULL, y = "Value")

```

### Beyond Pseudo-Randomness

Halton sequences [@halton1960] represent a fundamental advancement over pseudo-random numbers:

- **Deterministic** (not random)
- **Low-discrepancy** (fill space uniformly)
- **Number-theoretically constructed** using prime bases
- **Mathematically guaranteed** uniform coverage

### The Random Number Problem

Pseudo-random numbers inevitably cluster due to the birthday paradox:

**Example**: In 100 random points on [0, 1]:

- Expected maximum gap: $~0.05$
- Expected minimum gap: $~0.0001$
- Visual artifacts mislead analysts
- Density perception becomes unreliable

### Halton's Solution

Place each new point as far as possible from all previous points through systematic construction using the **van der Corput sequence**.

```{r halton-example, fig.cap="Van der Corput vs. pseudorandom", out.width="45%"}
knitr::include_graphics(img_van_der)
```


### Van der Corput Sequence Construction

The van der Corput sequence in base 2 generates a low-discrepancy sequence by:

1. Take integer index $i$
2. Convert to binary
3. Reverse the binary digits
4. Interpret as binary fraction

**Example**:

| $i$ | Binary | Reversed | Decimal $h_i$ |
|-----|--------|----------|---------------|
| 0   | 0      | 0        | 0.0           |
| 1   | 1      | 1        | 0.5           |
| 2   | 10     | 01       | 0.25          |
| 3   | 11     | 11       | 0.75          |
| 4   | 100    | 001      | 0.125         |
| 5   | 101    | 101      | 0.625         |
| 6   | 110    | 011      | 0.375         |
| 7   | 111    | 111      | 0.875         |

**Pattern**: Each point bisects the largest remaining gap.

```{r vdc-example, fig.cap="Van der Corput Sequence Visual", out.width="45%"}
knitr::include_graphics(img_vdc)
```

### Mathematical Formulation

For observation $i$ in a tie group:

$$h_i = \text{VanDerCorput}(i, \text{base}=2)$$

$$\text{displacement}_i = \epsilon \times (h_i - 0.5)$$

Centering around 0.5 creates symmetric bidirectional displacement.

### Theoretical Guarantees: Discrepancy Theory

**Star Discrepancy** measures how uniformly points fill an interval [@niederreiter1992]:

$$D_n^* = \sup_{I \subseteq [0,1]} \left|\frac{\#\{x_i \in I\}}{n} - |I|\right|$$

**Theoretical Bounds**:

- **Random sequences**: $D_n = O(n^{-1/2})$
- **Halton sequences**: $D_n = O(n^{-1} \log n)$
- **Optimal lower bound**: $D_n = \Omega(n^{-1} \log n)$

**Conclusion**: Halton sequences are **near-optimal** in the information-theoretic sense.

### Algorithm Pseudocode

```
function van_der_corput(i, base):
    result = 0
    denominator = base
    while i > 0:
        result += (i mod base) / denominator
        i = floor(i / base)
        denominator *= base
    return result

function halton_jitter(tied_values, epsilon):
    n = length(tied_values)
    displacements = empty_array(n)
    
    for i from 0 to n-1:
        h = van_der_corput(i, 2)
        displacements[i+1] = epsilon * (h - 0.5)
    
    return tied_values + displacements
```

<!-- ## Computational Complexity -->

<!-- - **Van der Corput generation**: $O(\log n)$ per point -->
<!-- - **Per tie group**: $O(n \log n)$  -->
<!-- - **Practical performance**: Very fast due to simple bit operations -->
<!-- - **Memory**: $O(n)$ for displacement array -->

<!-- ## Advantages -->

<!-- 1. **Mathematical guarantees**: Proven optimal distribution -->
<!-- 2. **No clustering**: Eliminates birthday paradox artifacts -->
<!-- 3. **Predictable**: Always fills largest gaps first -->
<!-- 4. **Efficient**: Simple bit operations -->
<!-- 5. **Extensible**: Easily extended to higher dimensions using different prime bases -->

### Applications in Computer Science

Halton sequences are widely used in:

- **Quasi-Monte Carlo integration**: Better convergence than random sampling
- **Computer graphics**: Anti-aliasing, global illumination
- **Ray tracing**: Sample generation for realistic rendering
- **Numerical analysis**: Multidimensional quadrature
- **Machine learning**: Hyperparameter search spaces

### Higher-Dimensional Extensions

For 2D applications (e.g., scatter plots):

$$x_i = \text{VanDerCorput}(i, 2) \quad \text{(base 2 for x-axis)}$$
$$y_i = \text{VanDerCorput}(i, 3) \quad \text{(base 3 for y-axis)}$$

Using different prime bases for each dimension maintains low-discrepancy properties.

## Method 3: Intelligent Jitter (Novel Exploration)

```{r intelligent-demo, fig.cap="Intelligent jittering resolves ties", fig.width=10, fig.height=5}
# Demonstration of intelligent jitter
p4 +
  iris_scale_color() +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  labs(title = "intelligent Jitter",
       x = NULL, y = "Value")

```

### Design Motivation

**Research Question**: Can we apply the golden ratio directly in 1D rather than through angular spacing?

The Intelligent jitter was developed to explore whether:

- Direct golden ratio modulation could work in 1D
- Linear scaling might provide progressive reveal
- A simpler algorithm could match Sunflower performance

### Mathematical Formulation

For observation $j$ in a tie group of size $n_{\text{ties}}$:

$$\text{angle}_j = (j-1) \times 2\pi \times 0.618$$

$$\text{displacement}_j = \epsilon \times \cos(\text{angle}_j) \times \frac{j-1}{n_{\text{ties}}}$$

### Key Distinctions from Sunflower

| Feature | Sunflower | Intelligent |
|---------|-----------|-------------|
| Angle | Golden angle ($137.5^\circ$) | Golden ratio × $2\pi (224.4^\circ)$ |
| Scaling | Square root: $\sqrt{j/n}$ | Linear: $j/n$ |
| Projection | 2D spiral $\rightarrow$ 1D | 1D cosine modulation |
| Inspiration | Phyllotaxis patterns | Golden ratio mathematics |

### Initial Hypothesis

**Progressive Reveal**: Linear scaling would create:

- **Early observations**: Small displacement (stay near true value)
- **Later observations**: Larger displacement (fill available space)
- **Golden ratio modulation**: Optimal distribution through natural constant

This would provide intuitive interpretation: "early arrivals" cluster near the true value, while "late arrivals" spread outward.

```{r golden-ratio, fig.cap="1-dimension Example of the Golden Ratio", out.width="35%"}
knitr::include_graphics(img_golden_ratio)
```

### Empirical Reality: Failure Analysis

The Intelligent jitter produced **poor visual quality** with several critical problems:

#### Problem 1: Excessive Displacement

For a tie group with $n = 100$ observations:

| Observation | Displacement |
|-------------|--------------|
| 1          | 0% of $\epsilon$ |
| 25         | ~24% of $\epsilon$ |
| 50         | ~49% of $\epsilon$ |
| 75         | ~74% of $\epsilon$ |
| 100        | ~99% of $\epsilon$ |

**Result**: Later observations displaced nearly to the boundary, creating false impression of substructure.

#### Problem 2: Artificial Stratification

The linear scaling creates **artificial layers** that don't represent actual data structure:

- Visual appearance suggests distinct sub-groups
- These "clusters" are algorithmic artifacts
- Misrepresents uniform density as stratified distribution

#### Problem 3: Perceptual Distortion

Users interpret visual patterns as data patterns:

- **Large gaps** appear meaningful (but are artifacts)
- **Density gradients** suggest ordering (but observations are exchangeable)
- **Boundary concentration** implies separation (but all values are tied)

### Algorithm Pseudocode

```
function intelligent_jitter(tied_values, epsilon):
    n = length(tied_values)
    golden_ratio = 0.618
    
    displacements = empty_array(n)
    
    for j from 1 to n:
        angle = (j - 1) * 2 * π * golden_ratio
        scale = (j - 1) / n
        displacements[j] = epsilon * cos(angle) * scale
    
    return tied_values + displacements
```

<!-- ## Computational Complexity -->

<!-- - **Per tie group**: $O(n)$ -->
<!-- - **Memory**: $O(n)$ -->
<!-- - **Performance**: Similar to other methods -->

### Why This Method Fails: Theoretical Analysis

#### Root Cause: Linear Scaling

The linear scaling function $\frac{j-1}{n}$ is inappropriate because:

1. **Violates uniformity**: Creates increasing displacement magnitudes
2. **Breaks perceptual validity**: Large displacements misrepresent true values
3. **Artificial ordering**: Imposes structure where none exists
4. **Cognitive interference**: Visual patterns contradict data properties

#### Comparison with Sunflower

Sunflower's $\sqrt{j/n}$ scaling maintains **constant area density** in 2D:

- Area of annulus at radius $r$: $\pi[(r+dr)^2 - r^2] \approx 2\pi r \, dr$
- For constant density: points per area = constant
- Therefore: $\frac{dN}{dA} \propto \frac{1}{r}$
- Solution: $N \propto r^2$, thus $r \propto \sqrt{N}$

Intelligent's linear scaling has **no such geometric justification**.

#### Value of This Negative Result

This failure provides important scientific contributions:

1. Design Pattern to Avoid

**Lesson**: Linear displacement scaling creates misleading stratification.

**Implication**: Future methods should use constant or sublinear scaling.

2. Golden Ratio Not Universal

**Lesson**: Golden ratio works in specific geometric contexts (angular distribution), not universally.

**Implication**: Biomimetic approaches require careful adaptation, not blind application.

3. Importance of Scaling Function

**Lesson**: The scaling function is as critical as the distribution algorithm.

**Implication**: Algorithm design must consider both angular distribution and radial scaling together.

4. Empirical Validation Essential

**Lesson**: Theoretical elegance doesn't guarantee practical effectiveness.

**Implication**: User studies and visual assessment are necessary even for mathematically motivated methods.

Recommendations

**Do not use Intelligent jitter for production visualizations.**

Include in research as:

- **Comparison baseline**: Shows what not to do
- **Methodological contribution**: Documents design failure
- **Educational value**: Teaches importance of scaling functions
- **Scientific rigor**: Negative results advance knowledge

# Comparative Analysis of Methods

```{r comparison-all, fig.cap="Side-by-side comparison of all jittering methods", fig.width=12, fig.height=8}
# Create comparison grid
grid.arrange(
  p1_zoom + labs(title = "No Jitter"),
  p2_zoom + labs(title = "Halton"),
  p3_zoom + labs(title = "Sunflower"),
  p4_zoom + labs(title = "Intelligent"),
  ncol = 2
)
```

## Dimensional Analysis

| Method | Approach | Dimension | Projection |
|--------|----------|-----------|------------|
| **Halton** | Pure 1D sequence | 1D | None |
| **Sunflower** | 2D spiral | 2D $\rightarrow$ 1D | Cosine |
| **Intelligent** | 1D with 2D-inspired modulation | Hybrid | Cosine |

## Scaling Behavior

| Method | Scaling Function | Growth Rate | At $n=50$, $j=25$ |
|--------|-----------------|-------------|-------------------|
| **Halton** | Uniform distribution | Constant | ~0.5 $\epsilon$ |
| **Sunflower** | $\sqrt{j/n}$ | Sublinear | ~0.7 $\epsilon$ |
| **Intelligent** | $j/n$ | Linear | ~0.5 $\epsilon$ |

## Distribution Quality Metrics

### Minimum Separation Distance

Smallest gap between any two consecutive points:

- **Halton**: Guaranteed $O(1/n)$, highly predictable
- **Sunflower**: Approximately $O(1/\sqrt{n})$ in projection, variable
- **Intelligent**: Highly variable, depends on cosine phase

### Discrepancy (Uniformity Measure)

How evenly points fill the interval:

- **Halton**: $O(n^{-1} \log n)$ — near-optimal 
- **Sunflower**: Not directly measurable in 1D projection, but empirically good
- **Intelligent**: Poor due to linear scaling creating density gradients

### Visual Clustering

Tendency to create artificial clusters:

- **Halton**: Minimal — systematic gap-filling 
- **Sunflower**: Slight central concentration (natural)
- **Intelligent**: Severe stratification artifacts

<!-- ## Computational Performance -->

<!-- All three methods share similar computational profiles: -->

<!-- | Operation | Complexity | Notes | -->
<!-- |-----------|-----------|--------| -->
<!-- | Identify Ties | $O(N \log N)$ | Sorting required | -->
<!-- | Generate Displacements | $O(k)$ | Per tie group size $k$ | -->
<!-- | Apply to Data | $O(N)$ | Linear in observations | -->
<!-- | **Overall** | **$O(N \log N)$** | Dominated by tie detection | -->

<!-- **Practical Performance** (tested on 100,000 observations): -->

<!-- - All methods: <100ms response time -->
<!-- - Real-time interaction maintained -->
<!-- - No memory issues -->
<!-- - Scalable to large datasets -->

<!-- ## Perceptual Validity Assessment -->

<!-- How well do visual patterns represent data properties? -->

<!-- | Method | Density Representation | Value Preservation | Artifact Level | -->
<!-- |--------|----------------------|-------------------|----------------| -->
<!-- | **Halton** | Excellent ✓ | Excellent ✓ | Minimal ✓ | -->
<!-- | **Sunflower** | Very Good ✓ | Very Good ✓ | Slight (acceptable) ✓ | -->
<!-- | **Intelligent** | Poor ✗ | Poor ✗ | Severe ✗ | -->

## Aesthetic Quality

Subjective but important for user acceptance:

- **Halton**: Clean, mechanical, predictable
- **Sunflower**: Organic, pleasing, natural
- **Intelligent**: Artificial, stratified, problematic

## Use Case Recommendations

### Halton: Best for...

- **Precision-critical applications**: Scientific publications
- **Maximum uniformity**: When faithful density representation is paramount
- **Mathematical rigor**: When provable guarantees matter
- **Large datasets**: Efficient, predictable performance

### Sunflower: Best for...

- **General purpose**: Good balance of properties
- **Aesthetic presentations**: Visually appealing
- **Exploratory analysis**: Natural-looking distributions
- **User preference**: Often preferred in studies

### Intelligent: Best for...

- **Methodological research**: As a comparison baseline
- **Educational examples**: Teaching what not to do
- **Negative controls**: Demonstrating failure modes
- **Do NOT use for production visualizations**

# Integration with ggpcp Package

## Architectural Integration

The `ggpcp` package implements a grammar of graphics approach with three core modules:

1. **Variable Selection** (`pcp_select`): Choose and order dimensions
2. **Axis Scaling** (`pcp_scale`): Normalize or transform scales
3. **Tie Resolution** (`pcp_arrange`): Handle overlapping values $\leftarrow$ **EXTENDED**

Our contribution extends `pcp_arrange` to handle numerical ties alongside existing categorical tie-breaking.

## Proposed Software Implementation

### Function Signature

```r
pcp_arrange(
  data,
  method = c("from-left", "from-right", "halton", "sunflower", "intelligent"),
  space = 0.05,
  epsilon = NULL,
  numeric_ties = TRUE
)
```

### Parameters

- **method**: Tie-breaking strategy
  - `"from-left"`, `"from-right"`: Existing categorical methods
  - `"halton"`: Quasi-random low-discrepancy sequence
  - `"sunflower"`: Biomimetic golden angle distribution
  - `"intelligent"`: Golden ratio linear (research only)
  
- **space**: Proportion of axis for categorical spacing (existing parameter)

- **epsilon**: Maximum displacement for numerical ties
  - `NULL` (default): Auto-determined as 0.05 * axis range
  - Numeric value: User-specified displacement magnitude
  
- **numeric_ties**: Whether to apply jittering to numerical ties (default: TRUE)

### Example Usage

```r
library(ggpcp)
library(dplyr)

# Basic usage with Sunflower (recommended default)
iris_plot <- iris %>%
  pcp_select(1:5) %>%
  pcp_scale(method = "uniminmax") %>%
  pcp_arrange(method = "sunflower") %>%
  ggplot() +
  geom_pcp()

# Halton for maximum uniformity
iris_halton <- iris %>%
  pcp_select(Sepal.Length:Species) %>%
  pcp_scale(method = "uniminmax") %>%
  pcp_arrange(
    method = "halton",
    epsilon = 0.08,
    numeric_ties = TRUE
  ) %>%
  ggplot() +
  geom_pcp(aes(color = Species))

# Mixed categorical and numerical ties
mixed_data %>%
  pcp_select(cat1, num1, cat2, num2) %>%
  pcp_arrange(
    method = "sunflower",  # Applied to numerical
    space = 0.05           # Applied to categorical
  )

# Comparison of methods
library(patchwork)

p_none <- iris %>% pcp_select(1:4) %>% 
  pcp_arrange(method = "none") %>% plot_pcp()
  
p_halton <- iris %>% pcp_select(1:4) %>% 
  pcp_arrange(method = "halton") %>% plot_pcp()
  
p_sunflower <- iris %>% pcp_select(1:4) %>% 
  pcp_arrange(method = "sunflower") %>% plot_pcp()

(p_none | p_halton | p_sunflower) +
  plot_annotation(title = "Comparison of Tie-Breaking Methods")
```

## Implementation Strategy

### 1. Automatic Tie Detection

```r
detect_numerical_ties <- function(values, tolerance = .Machine$double.eps^0.5) {
  # Group values within tolerance
  # Return list of tie groups with indices
}
```

### 2. Method Dispatch

```r
apply_numerical_jitter <- function(data, method, epsilon) {
  switch(method,
    "halton" = halton_jitter(data, epsilon),
    "sunflower" = sunflower_jitter(data, epsilon),
    "intelligent" = intelligent_jitter(data, epsilon),
    "none" = data
  )
}
```

### 3. Preservation of Original Values

```r
# Store original values in metadata
attr(jittered_data, "original_values") <- original_values
attr(jittered_data, "jitter_method") <- method
attr(jittered_data, "epsilon") <- epsilon
```

## Backward Compatibility

- Existing `pcp_arrange` calls continue to work unchanged
- Default behavior (categorical-only) preserved when `numeric_ties = FALSE`
- New functionality opt-in through explicit method selection
- Warning messages guide users to new features

## Documentation Requirements

### Function Documentation

- Detailed explanation of each method
- Theoretical foundations and references
- When to use each method
- Parameter selection guidance
- Examples with multiple datasets

### Vignettes

1. **"Handling Numerical Ties in ggpcp"**: Introduction and basic usage
2. **"Comparing Tie-Breaking Methods"**: Detailed comparison with examples
3. **"Advanced Tie Resolution"**: Parameter tuning and edge cases
4. **"Theory of Deterministic Jittering"**: Mathematical foundations

### Visual Indicators

Add optional visual indicators showing:

- Which axes have numerical tie-breaking applied
- Magnitude of epsilon used
- Number of tied observations per group
- Method employed

# Research Questions and Methodology

## Primary Research Question

**How can the formal structure of the Grammar of Graphics be extended to systematically incorporate and evaluate methods for resolving numerical ties in parallel coordinate plots, and what is the quantifiable impact of these methods on the accuracy and efficiency of visual data analysis?**

## Secondary Research Questions

### RQ1: Theory

**How can the management of numerical ties be most effectively and coherently formalized within the layered grammar of graphics, building on the established ggpcp framework for categorical tie management?**

**Methodology**:

- Theoretical analysis of Grammar of Graphics structure
- Literature synthesis on position adjustments
- Specification of new grammatical element
- Integration with existing ggpcp architecture
- Formal documentation of tie-breaking grammar

**Deliverables**:

- Formal specification document
- Extended grammar notation
- Theoretical paper on biomimetic transformations
- Integration guidelines for ggpcp

### RQ2: Methodology

**What are the optimal algorithmic criteria for ordering and spacing tied data points to maximize visual clarity while preserving underlying data properties, particularly in comparison to the hierarchical sorting methods already established in ggpcp for categorical variables?**

**Methodology**:

- Algorithm design and implementation in R
- Comparative analysis of distribution quality
- Computational performance benchmarking
- Parameter sensitivity analysis
- Edge case identification and handling

**Evaluation Metrics**:

- Minimum separation distance
- Discrepancy (uniformity measure)
- Computational complexity
- Memory efficiency
- Scalability testing

**Deliverables**:

- Complete R implementation in ggpcp
- Performance benchmarks
- Algorithm comparison paper
- Best practices guidelines

### RQ3: Perception

**How do different visualization strategies for numerical ties affect an analyst's ability to perform key visual tasks (cluster identification, outlier detection, density estimation) compared to the categorical tie-breaking approaches already validated in ggpcp?**

**Methodology**: Controlled user study with human subjects

**Study Design**:

- **Type**: Within-subjects repeated measures
- **Participants**: 30-50 analysts (mixed expertise)
- **Methods compared**: No jitter, Random, Halton, Sunflower, Intelligent
- **Tasks**: 
  - Density estimation: "How many observations follow this path?"
  - Cluster identification: "Identify distinct clusters"
  - Outlier detection: "Find observations that don't fit patterns"
  - Pattern tracing: "Follow observation 42 across all dimensions"

**Dependent Variables**:

1. **Accuracy**: Absolute error from ground truth
2. **Completion Time**: Seconds to complete task
3. **Confidence**: Self-reported certainty (1-10 scale)
4. **Preference**: Comparative ranking of methods

**Statistical Analysis**:

- Repeated-measures ANOVA
- Bonferroni post-hoc tests
- Effect size calculations (partial $\eta^2$)
- Correlation analysis (accuracy vs. confidence)

**Expected Hypotheses**:

- **H1**: Halton and Sunflower > Random > No Jitter (accuracy)
- **H2**: Halton $\approx$ Sunflower < Random < No Jitter (time)
- **H3**: Sunflower $\approx$ Halton > Random > No Jitter (preference)
- **H4**: Intelligent performs poorly across all metrics

**Deliverables**:

- IRB-approved study protocol
- Complete dataset with results
- Statistical analysis report
- Empirical paper on perceptual effectiveness

### RQ4: Practice

**Can a set of evidence-based heuristics be developed to guide practitioners in selecting the most appropriate numerical tie-breaking method for their specific data context, integrating with existing ggpcp parameter selection guidelines?**

**Methodology**:

- Synthesize findings from RQ1-3
- Develop decision tree/flowchart
- Validate with case studies
- Gather practitioner feedback
- Refine through iterative testing

**Case Study Domains**:

1. **Bioinformatics**: Gene expression data
2. **Finance**: Market data with discrete prices
3. **Engineering**: Sensor data with limited precision
4. **Social Science**: Survey responses with Likert scales
5. **Climate Science**: Model ensemble outputs

**Heuristic Framework Components**:

- Data characteristics assessment
- Task requirements analysis
- Method selection guidelines
- Parameter tuning recommendations
- Validation procedures

**Deliverables**:

- Practitioner's guide document
- Interactive decision tool (Shiny app)
- Case study collection
- Best practices paper
- Tutorial videos

# Implementation Roadmap

## Phase 1: Algorithm Refinement (Winter 2025)

### Tasks

1. Finalize all three jittering implementations
2. Develop adaptive epsilon selection
3. Optimize computational performance
4. Complete test suite with edge cases
5. Benchmark against large datasets

### Deliverables

- Optimized R functions
- Unit tests with 100% coverage
- Performance benchmarks
- Technical documentation

## Phase 2: ggpcp Integration (Spring 2026)

### Tasks

1. Extend `pcp_arrange()` function
2. Implement automatic tie detection
3. Add epsilon auto-determination
4. Create visual indicators
5. Write package vignettes
6. Prepare for CRAN submission

### Deliverables

- Updated ggpcp package
- Comprehensive documentation
- Three tutorial vignettes
- Package ready for CRAN

## Phase 3: User Study (Spring-Summer 2026)

### Tasks

1. Obtain IRB approval (early Spring)
2. Develop study materials
3. Recruit participants
4. Conduct study sessions
5. Analyze results
6. Write empirical paper

### Deliverables

- IRB approval documentation
- Complete dataset
- Statistical analysis
- Empirical research paper draft

## Phase 4: Case Studies & Dissertation Writing (Summer 2026)

### Tasks

1. Apply to diverse real-world datasets
2. Gather practitioner feedback
3. Develop decision heuristics
4. Write dissertation chapters
5. Integrate all components
6. Prepare defense presentation

### Deliverables

- Five domain case studies
- Practitioner's guide
- Complete dissertation draft
- Defense presentation

## Phase 5: Final Review and Defense (May-July 2026)

### Tasks

1. Committee review of dissertation
2. Incorporate feedback
3. Final revisions
4. Defense rehearsals
5. Dissertation defense

### Deliverables

- Final dissertation
- Successful defense
- Submitted for graduation


# Expected Outcomes and Contributions

## Theoretical Contributions

1. **Grammar of Graphics Extension**
   - Formal specification of biomimetic transformations
   - Integration of natural optimization principles
   - New category of position adjustments

2. **Cross-Domain Algorithm Adaptation**
   - Phyllotaxis $\rightarrow$ data visualization
   - Quasi-random sequences $\rightarrow$ statistical graphics
   - Demonstrates value of interdisciplinary approaches

3. **Negative Result Documentation**
   - Intelligent jitter failure analysis
   - Design patterns to avoid
   - Methodological lessons

## Methodological Contributions

1. **Three Novel Algorithms**
   - Halton jitter for PCPs
   - Sunflower jitter for PCPs
   - Intelligent jitter (with failure analysis)

2. **Comparative Framework**
   - Systematic evaluation criteria
   - Quantitative metrics
   - Perceptual assessment methods

3. **Implementation Quality**
   - Production-ready R code
   - Comprehensive testing
   - Extensive documentation

## Practical Contributions

1. **ggpcp Package Enhancement**
   - Complete tie-handling solution
   - Categorical + numerical ties
   - Unified grammar interface

2. **User Guidance**
   - Evidence-based selection heuristics
   - Interactive decision tools
   - Tutorial materials

3. **Real-World Impact**
   - Improved exploratory data analysis
   - More accurate pattern detection
   - Better density visualization

## Empirical Contributions

1. **User Study Results**
   - Quantitative performance data
   - Perceptual effectiveness measures
   - Preference rankings

2. **Case Study Collection**
   - Diverse domain applications
   - Best practices examples
   - Common pitfall documentation

3. **Benchmark Dataset**
   - Performance comparisons
   - Scalability testing
   - Reference implementations

# Broader Implications

## Beyond Parallel Coordinates

The methods developed here generalize to other visualization contexts:

### 2D Scatter Plots

**Problem**: Overplotting with tied values

**Solution**: Full 2D Sunflower and 2D Halton

```r
# 2D Sunflower for scatter plots
scatter_sunflower <- function(x_ties, y_ties, epsilon) {
  n <- length(x_ties)
  angles <- (0:(n-1)) * 137.508 * (pi/180)
  radii <- epsilon * sqrt((0:(n-1)) / n)
  
  x_displaced <- x_ties + radii * cos(angles)
  y_displaced <- y_ties + radii * sin(angles)
  
  return(data.frame(x = x_displaced, y = y_displaced))
}
```

### Time Series Visualization

**Problem**: Multiple series with identical values at time points

**Solution**: Vertical displacement using deterministic methods

### Network Visualization

**Problem**: Node positioning with spatial constraints

**Solution**: Optimal space-filling using golden angle principles

## General Principle

**Wherever random jitter is currently used, deterministic low-discrepancy alternatives should be considered.**

Benefits:

- Reproducibility
- Better distribution quality
- Elimination of artifacts
- Theoretical guarantees

# Timeline to Dissertation Defense

| Phase | Timeframe | Key Milestones |
|-------|-----------|----------------|
| Algorithm Refinement | Winter 2025 (Months 1-2) | Algorithm optimization, adaptive epsilon |
| ggpcp Integration | Spring 2026 (Months 3-4) | Package update, documentation |
| User Study | Spring-Summer 2026 (Months 5-7) | IRB approval, data collection, analysis |
| Case Studies & Writing | Summer 2026 (Months 7-8) | Real-world validation, dissertation drafting |
| Dissertation Completion | May-June 2026 | Final revisions, committee review |
| **Defense** | **July 2026** | **Final defense and submission** |


# Conclusion

This research addresses a fundamental limitation in parallel coordinate visualization: the visual occlusion caused by numerical ties. 
While the ggpcp package has successfully solved categorical ties through hierarchical sorting, numerical ties have remained problematic.

We propose three deterministic jittering methods, Halton (quasi-random sequences), Sunflower (biomimetic distribution), and Intelligent (exploratory approach), that provide reproducible, theoretically-grounded solutions.
Our comparative analysis reveals:

- **Halton excels** in uniformity and mathematical rigor
- **Sunflower balances** performance with aesthetic appeal
- **Intelligent demonstrates** the importance of proper scaling functions

The integration of these methods into ggpcp will provide users with a complete solution for all forms of ties, categorical and numerical—within a unified Grammar of Graphics framework. 
This research contributes to visualization theory, methodology, and practice while establishing principles applicable beyond parallel coordinates.

The planned user study will provide empirical evidence for method selection, while case studies will demonstrate real-world effectiveness. 
Together, these components will deliver evidence-based guidance for practitioners and advance the theoretical understanding of position adjustments in statistical graphics.

By incorporating nature-inspired optimization principles into data visualization, this work exemplifies how cross-disciplinary approaches can solve longstanding challenges in information visualization.

# References

::: {#refs}
:::
